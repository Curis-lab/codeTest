const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const db = require("../config/db");


function normalizeRole(userInput) {
  const input = userInput.toLowerCase().trim(); // Normalize input to lowercase and trim spaces

  if (/^super[\s_]?admin$/i.test(input)) {
    return "super_admin";
  } else if (/^admin$/i.test(input)) {
    return "admin";
  } else if (/^manager$/i.test(input)) {
    return "manager";
  } else if (/^normal[\s_]?user$/i.test(input)) {
    return "normal_user";
  } else {
    return null; // Return null or handle as invalid input
  }
}

exports.login = (req, res) => {
  const { email, password } = req.body;
  db.query(
    "SELECT * FROM users WHERE email = ?",
    [email],
    async (err, results) => {
      if (err) return res.status(500).json({ error: "Database error" });

      if (results.length === 0) {
        return res.status(404).json({ error: "User not found" });
      }

      const user = results[0];
      const isMatch = await bcrypt.compare(password, user.password);

      if (!isMatch) {
        return res.status(400).json({ error: "Invalid credentials" });
      }

      db.query(
        `
        SELECT u.userId, u.email, r.roleId, r.name AS roleName
        FROM user_role ur
        JOIN users u ON ur.userId = u.userId
        JOIN roles r ON ur.roleId = r.roleId
        WHERE u.userId = ?`,
        [user.userId],
        (err, result) => {
          if (err) return res.status(500).json({ error: "did not found role" });

          const token = jwt.sign(
            {
              userId: user.userId,
              email: user.email,
              role: normalizeRole(result[0].roleName),
            },
            process.env.JWT_SECRET,
            { expiresIn: "1h" }
          );
          res.json({ token });
        }
      );
    }
  );
};

exports.register = async (req, res) => {
  const { name, email, password, departmentId, role } = req.body;

  try {
    // Check if email already exists
    db.query(
      "SELECT * FROM users WHERE email = ?",
      [email],
      async (err, results) => {
        if (err) return res.status(500).json({ error: "Database error" });

        if (results.length > 0) {
          return res.status(400).json({ error: "Email already registered" });
        }

        // Hash the password
        const hashedPassword = await bcrypt.hash(password, 10);

        // Insert into staff table first (assuming staff ID is autogenerated)
        const staffSql = "INSERT INTO staff (name, depId) VALUES (?, ?)";
        db.query(staffSql, [name, departmentId], (err, staffResult) => {
          if (err) return res.status(500).json({ error: "Database error" });

          const staffId = staffResult.insertId;

          // Insert into users table
          const userSql =
            "INSERT INTO users (email, password, staffId) VALUES (?, ?, ?)";
          db.query(
            userSql,
            [email, hashedPassword, staffId],
            (err, userResult) => {
              if (err) return res.status(500).json({ error: "Database error" });

              const userId = userResult.insertId;

              // Assign role to user
              const roleSql =
                "INSERT INTO user_role (userId, roleId, flag) VALUES (?, ?, 1)";

              //problem on this part
              db.query(
                "SELECT roleId FROM roles WHERE name = ?",
                [role],
                (err, roleResult) => {
                  if (err || roleResult.length === 0)
                    return res.status(500).json({ error: "Role not found" });

                  const roleId = roleResult[0].roleId;
                  db.query(roleSql, [userId, roleId], (err) => {
                    if (err)
                      return res.status(500).json({ error: "Database error" });

                    // Create JWT token
                    const token = jwt.sign(
                      { userId, email, staffId, role },
                      process.env.JWT_SECRET,
                      {
                        expiresIn: "1h",
                      }
                    );

                    res
                      .status(201)
                      .json({ message: "User registered successfully", token });
                  });
                }
              );
            }
          );
        });
      }
    );
  } catch (error) {
    res.status(500).json({ error: "Internal server error" });
  }
};
